<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<meta name=Generator content="Microsoft Word 15 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:等线;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@等线";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:等线;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"页眉 字符";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:等线;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"页脚 字符";
	margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:等线;}
span.a
	{mso-style-name:"页眉 字符";
	mso-style-link:页眉;}
span.a0
	{mso-style-name:"页脚 字符";
	mso-style-link:页脚;}
.MsoChpDefault
	{font-family:等线;}
 /* Page Definitions */
 @page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.WordSection1
	{page:WordSection1;}
-->
</style>

</head>

<body lang=ZH-CN style='text-justify-trim:punctuation'>

<div class=WordSection1 style='layout-grid:15.6pt'>

<p class=MsoNormal align=left style='text-align:left'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Raytracing</span>是模拟现实世界的一种方式，从摄像机的位置，通过影像平面上的像素位置，发射一束光线到场景，求光线和场景中最近的交掉，再求该交点的著色（如果该交点可以被光源直接照射到，也就是不在阴影部分中）。如果该交点的性质是反射性的，就可以在该交点向反射方向继续追踪。通过这样的递归追踪完成对现实世界的模拟，</p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><img
width=554 height=300 id="图片 2" src="lab4.files/image001.jpg"></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>实验的要求是在一个场景中一半的场景运用库函数进行<span
lang=EN-US>raytracing</span>渲染，一半利用自己实现的<span lang=EN-US>raytracing</span>函数进行渲染。这里我就直接调用了<span
lang=EN-US>opengl</span>的光照函数，据说这个函数的实现原理就是<span lang=EN-US>ray tracing</span>，下面就着重介绍一下我实现<span
lang=EN-US>raytracing</span>的过程。</p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>先贴一张效果图：</p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><img
width=607 height=562 id="图片 1" src="lab4.files/image002.jpg"></span></p>

<p class=MsoNormal align=left style='text-align:left'><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>这个我想大家都能看出来右边的那个是我实现的（这是一个被正斜上方光源照射的球体，大家可以稍微加入一点想象力想象一下）。下面介绍一下实现过程。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>右边的绿球的圆心坐标是在世界坐标的远点，半径是<span
lang=EN-US>0.3</span>，右边的黄球圆心左边是（<span lang=EN-US>-0.7</span>，<span lang=EN-US>0</span>，<span
lang=EN-US>0</span>），半径是<span lang=EN-US>0.2</span>（虽然比右边的大一号但是确实是这么设定的，至于为什么这么显示应该是<span
lang=EN-US>opengl</span>比例和我理解的不太一样），世界坐标系为右手坐标系，相机位置是在（<span lang=EN-US>0</span>，<span
lang=EN-US>0</span>，<span lang=EN-US>2</span>），屏幕位置是在（<span lang=EN-US>0</span>，<span
lang=EN-US>0</span>，<span lang=EN-US>1</span>）。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>用一个<span
lang=EN-US>60*60</span>的<span lang=EN-US>matrix</span>作为一个<span lang=EN-US>60*60</span>的屏幕，其中的每一个元素记录的是对应像素的位置（每一个像素大小是<span
lang=EN-US>0.01*0.01</span>），那么每一条穿过该像素的光线方向向量就是（<span lang=EN-US>i*0.01-0.3</span>，<span
lang=EN-US>0.3-j*0.01</span>，<span lang=EN-US>-1</span>），起始点的位置是相机位置，实现一个<span
lang=EN-US>rayfindinterset1</span>来计算光线和右边球体的交点，这个其实就是一个求解（<span lang=EN-US>x+t*dx,y+t*dy,z+t*dz</span>）和球体<span
lang=EN-US> x^2+y^2+z^2=0.09</span>交点的过程，（<span lang=EN-US>x</span>，<span
lang=EN-US>y</span>，<span lang=EN-US>z</span>）是相机位置，（<span lang=EN-US>dx</span>，<span
lang=EN-US>dy</span>，<span lang=EN-US>dz</span>）是光线方向向量，需要求解的是一个较小的<span
lang=EN-US>t</span>（如果无解就是不存在交点，），思路很简单也很好实现，这里就不贴出代码了。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>第一次求出交点后<span
lang=EN-US>matrix</span>的分部是这样的，可以看到还是很符合的：</p>

<p class=MsoNormal align=center style='text-align:center;text-indent:21.0pt'><span
lang=EN-US><img width=554 height=318 id="图片 3" src="lab4.files/image003.jpg"></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>接着就要盘带这些是否被光源照射到，本来应该是和上述思路一样的实现，但是发现这么做判别式将变得异常的繁琐，所以这里采用一个简化方法，求出该点到光线的方向向量，然后将这个法向量乘以一个极小值在加到交点上，得到的就是非常接近该点的另外一个点，判断这个点是否在球中就可以近似的作为原来的交点是否被光线直接照射的依据，考虑到整个场景的特殊性，我觉得这个应该还是成立的，该过程被实现为函数<span
lang=EN-US>ifshawdow</span>。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>之后我们还需要追踪其反射光线，这里实现一个<span
lang=EN-US>getspecular</span>函数得到该点处的反射光线，因为该点和原点的连线即为法向量，所以找到反射光线还是比较简单的，利用两向量内积得到投影比例<span
lang=EN-US>a</span>后用公式<span lang=EN-US> 2*N*a-R</span>即可得到。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>有了<span
lang=EN-US>getspecular</span>函数我们在可以得到反射光线的同时也利用这个函数对交点进行镜面反射渲染，详细的过程在实验<span
lang=EN-US>3</span>中都有描述这里就不再追逐，<span lang=EN-US>specular</span>渲染实现为函数<span
lang=EN-US>phongspecular</span>，得到的颜色值保存在<span lang=EN-US>matrix</span>中。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>接下来我们就要追踪反射光线了，由于场景中只有两个物体，所以反射光线只能和左边的球有交点或者直接就没有交点，这里就可以用<span
lang=EN-US>rayfindinterset1</span>一样的思路实习那<span lang=EN-US>rayfindinterset2</span>函数，然后，调用之后发现这些光线和黄球都没有交点。如果是真实世界的话右边绿球左半部分是应该存在一部分区域其反射光线和左边绿球是相交的，出现这样结果可能是因为两个球之间距离相对与它们的大小来说有点过大或者说像素过大太不精确导致那一部分区域由于精确度的问题被巧妙地避开了（这里强行忽略可能是我代码实现错误这个可能性最大的原因），那么到此位置光线追踪就完成了，现在<span
lang=EN-US>matrix</span>中就是每一个像素对应的像素值了，利用<span lang=EN-US>glfColor3f</span>和<span
lang=EN-US>glRectf</span>函数绘制到屏幕上了，至此整个实验就算结束了。</p>

<p class=MsoNormal align=left style='text-align:left'><span lang=EN-US>&nbsp;</span></p>

</div>

</body>

</html>
